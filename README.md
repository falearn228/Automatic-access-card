# Automatic-access-card

Конеченый автомат описывает конкретную задачу -> Для открытия двери пользователь должен вставить карту в считыватель, затем ввести правильный код. При вводе правильного кода система открывает дверь, иначе – выдается сообщение о запрете доступа. Дверь остается открытой пока карта не вытащена из считывателя.

Для решения задачи построен автомат представленный на рисунке 1.
Также стоит обратить внимание на свойства полученного по спецификации автомата, поскольку для детерминированных полностью определённых автоматов задача тестирования с гарантированной полнотой упрощается.

1.	Детерминированность: для каждого состояния и каждого входного символа (вставка карты, ввод кода и т.д.) определён один переход в следующее состояние. Нет неоднозначностей в переходах.
2.	Полная определённость: для каждого возможного входа в каждом состоянии, определено действие или переход, включая случаи игнорирования (например, ввод неправильного кода или вытаскивание карты).

![Picture](https://github.com/user-attachments/assets/03e710c7-f80e-4924-ad6c-c2c89855183c)

Все пары состояний один-различимы, то есть различимы по последовательности длины 1, следовательно, автомат минимизирован.

![derevo](https://github.com/user-attachments/assets/3c4685a5-dbee-43c8-bba0-a57af2155c3f)


Для выполнения задачи была разработана архитектура «Сервер-Прокси-Клиент», обеспечивающая функционирование и мониторинг модели системы управления дверным замком.

Сервер:

	Реализует поведение банкомата на основе заданной таблицы переходов и выходов.
	Обрабатывает команды и возвращает соответствующие ответы.

Клиент:

	Позволяет вручную отправлять запросы серверу.
	Предоставляет интерфейс для взаимодействия пользователя с системой.

Прокси-сервер:

	Выступает посредником между клиентом и сервером.
	Хранит копию таблицы переходов сервера для проверки корректности запросов и ответов.
	Анализирует соответствие запросов клиента и ответов сервера ожидаемым значениям. В случае несоответствия выводит уведомление в консоль.
	Блокирует запрещённые команды согласно таблице переходов цифрового двойника.
	Эта система позволяет не только проверить корректность работы сервера, но и протестировать его поведение в различных сценариях, включая ошибки в таблице переходов или некорректные команды.

Далее, из диагностического дерева (рисунок 2) были выбраны все установочные последовательности. Установочная последовательность — это последовательность, обозначающая путь от корня дерева до вершины с однородным сигма-списком. В дереве существуют установочные последовательности длиной не менее 1. Для выполнения задания необходимо перечислить все последовательности длиной не более 2, а именно:{(Код+, Карта+) (Код+, Карта-) (Карта+, Код+) (Карта+, Код-) (Карта+, Карта-) (Код-, Карта+) (Код-, Карта-) (Карта-, Код+) (Карта-, Код-) (Карта-, Карта+) (Карта-, Карта-)}

Выбрана последовательность (Код+, Карта-) alpha
Состояние	Реакции 	Конечное состояние, /-преемники
Состояние “Ожидание карты”	Игнор, игнор	Ожидание карты
Состояние “Карта вставлена”	+, +	Ожидание карты
Состояние “Дверь открыта”	Игнор, +	Ожидание карты

Выбрана последовательность (Код+, Код-) alpha
Состояние	Реакции 	Конечное состояние, alpha/gamma-преемники
Состояние “Ожидание карты”	Игнор, Игнор	Ожидание карты
Состояние “Карта вставлена”	+, игнор	Дверь открыта
Состояние “Дверь открыта”	Игнор, игнор	Дверь открыта

Как видим из (Код+, Карта-) последовательность / , непустые /-преемники всех состояний автомата совпадают. Из этого следует, что (Код+, Карта-) является установочной последовательностью.
Анализ покрытия
Следующим этапом лабораторной работы является анализ эффективности разработанных инструментов.
Для инструмента мониторинга трафика на основе цифрового двойника требуется выполнить следующие действия.
1. Продемонстрировать два сценария работы мониторинга на основе двойника в режиме ручной подачи входных воздействий на стороне клиента a) внести в серверную реализацию ошибку перехода и ошибку выхода, проверить, будут ли они обнаружены; b) пометить один из переходов цифрового дневника как небезопасный/запрещённый, проверить, заблокирует ли система такое воздействие.

Реализуем оба сценария пошагово. Для наглядности добавим логирование в прокси-сервер.

Сценарий A: Обнаружение ошибки перехода и выхода

1.	Внесем ошибку перехода в серверный код (server/main.go):


2.	Запустим систему

3.	Выполним в клиенте: Карта+ -> Код+

4.	Логи прокси сервера 

![logs1](https://github.com/user-attachments/assets/789d7510-2bd2-436d-b343-d68cb1e279dc)


5.	Реакция системы:
	Клиент получит ответ: CardInserted → WaitingForCard
	Прокси выведет предупреждение в консоль о несоответствии
	Сервер останется в некорректном состоянии

Сценарий B: Блокировка запрещённого перехода

1.	Пометим переход как запрещённый в прокси (proxy/main.go):

 ![logs2](https://github.com/user-attachments/assets/f780d4d1-78b1-49fd-b61b-a87ad5c2f7fa)


2.	Запускаем систему

3.	Выполняем в клиенте такие же шаги (карта+, код-)

4.	Наблюдаем реакцию прокси сервера.

![logs3](https://github.com/user-attachments/assets/526f413b-b776-4591-8486-fddcac24062f)


5.	Проверка состояния:
	Сервер остался в состоянии CardInserted
	Переход не произошел

Анализ результатов:

Сценарий	Обнаружение ошибки	Блокировка	Состояние сервера

A (Ошибочный переход)	✅ (В консоли прокси)	❌	Некорректное

B (Запрещённая команда)	✅	✅	Не изменено

Прокси-сервер действует как:
	Фильтр команд (для сценария B)
	Валидатор состояний (для сценария A)

Эти тесты подтверждают, что система мониторинга успешно обнаруживает ошибки переходов и выходов, а также корректно блокирует небезопасные команды. Таким образом поведение программы на тестах выше соответствует ожидаемым результатам.

Следующий тест проводится с переводом клиента в режим генерации случайного трафика. 
Для проверки, все ли состояния сервера могут быть идентифицированы установочными последовательностями. Был проведен ряд тестов, в последствии которого установлено, состояния сервера определяются заданными последовательностями. 
Например:
"код+ → карта-" приводит к состоянию “Ожидание карты”.
Далее переведя клиент в режим генерации случайного трафика. 
Проведены тесты для построения зависимости процента покрытых переходов объёма проанализированного трафика:
После выполнения более 100 случайных запросов покрытие остановилось на уровне 50%. (см. Рисунок 3). На рисунке 4 можно увидеть получившейся график, где 35 итераций и 15 переходов было обнаружено системой.

![logs4](https://github.com/user-attachments/assets/08bd7f27-d34f-42a3-a2e3-2dd10d25269b)


Рисунок 3 – результаты тестирования после прогона случайной генерации трафика

![logs5](https://github.com/user-attachments/assets/0ae538b5-f896-4d2e-ba87-5f7c7beebc89)


Рисунок 4 – график зависимости покрытия в зависимости от итерации

Анализ покрытия с внесённой неисправностью. Далее была внесена неисправность в сервер, чтобы прокси не могло отслеживать состояние. Неисправность заключается в том, что сервер всегда возвращает ”Unknown event” со статусом 400.

Прокси фиксирует несоответствие. Переходы не покрываются, идентификация состояния не происходит, в следствие чего покрытие равно 0. Демонстрация на рисунке Рисунок 5.

![logs6](https://github.com/user-attachments/assets/98a22b4e-450d-4611-9590-1db2ce36192b)


Рисунок 5 – результаты тестирования после внесения ошибки в сервер

Вывод: Проведённые испытания подтвердили корректную работу системы мониторинга дискретных систем. Прокси-сервер успешно обнаруживает ошибки переходов и выходов, что подтверждает эффективность применения цифрового двойника. Однако, при случайной генерации трафика выяснилось, что не все переходы могут быть охвачены, что подчёркивает важность систематического подхода к тестированию. Внедрение неисправности на сервере показало, что прокси способен выявить проблему, но это может затруднить точное определение состояния системы.
